<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JaxbContextBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Common Xml</a> &gt; <a href="index.source.html" class="el_package">org.bremersee.xml</a> &gt; <span class="el_source">JaxbContextBuilder.java</span></div><h1>JaxbContextBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2020-2022  the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bremersee.xml;

import java.util.Collection;
import java.util.Iterator;
import java.util.Optional;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.stream.StreamSupport;
import jakarta.xml.bind.Marshaller;
import jakarta.xml.bind.Unmarshaller;
import jakarta.xml.bind.ValidationEventHandler;
import jakarta.xml.bind.annotation.XmlRootElement;
import jakarta.xml.bind.annotation.XmlType;
import jakarta.xml.bind.annotation.adapters.XmlAdapter;
import jakarta.xml.bind.attachment.AttachmentMarshaller;
import jakarta.xml.bind.attachment.AttachmentUnmarshaller;
import javax.xml.validation.Schema;

/**
 * The jaxb context builder.
 *
 * @author Christian Bremer
 */
public interface JaxbContextBuilder {

  /**
   * The default dependencies resolver implementation.
   */
<span class="fc" id="L45">  JaxbDependenciesResolver DEFAULT_DEPENDENCIES_RESOLVER = new JaxbDependenciesResolverImpl();</span>


  /**
   * Creates a new jaxb context builder.
   *
   * @return the jaxb context builder
   */
  static JaxbContextBuilder newInstance() {
<span class="fc" id="L54">    return new JaxbContextBuilderImpl();</span>
  }


  /**
   * Copy jaxb context builder.
   *
   * @return the jaxb context builder
   */
  JaxbContextBuilder copy();

  /**
   * Specifies whether to add a schema to the marshaller or unmarshaller. The default is to add
   * never a schema to the marshaller or unmarshaller.
   *
   * @param schemaMode the schema mode
   * @return the jaxb context builder
   * @see SchemaMode#NEVER
   * @see SchemaMode#ALWAYS
   * @see SchemaMode#MARSHAL
   * @see SchemaMode#UNMARSHAL
   * @see SchemaMode#EXTERNAL_XSD
   */
  JaxbContextBuilder withSchemaMode(SchemaMode schemaMode);

  /**
   * Specifies the schema builder to generate the schema. The default is the default schema builder
   * implementation (see {@link SchemaBuilder#newInstance()}).
   *
   * @param schemaBuilder the schema builder
   * @return the jaxb context builder
   */
  JaxbContextBuilder withSchemaBuilder(SchemaBuilder schemaBuilder);

  /**
   * Specifies the dependencies-resolver to use. The default jaxb context builder will use a default
   * implementation.
   *
   * &lt;p&gt;To turn off dependency resolving set {@code null} here.
   *
   * @param resolver the resolver
   * @return the jaxb context builder
   */
  JaxbContextBuilder withDependenciesResolver(JaxbDependenciesResolver resolver);

  /**
   * Specifies the class loader to use.
   *
   * @param classLoader the class loader
   * @return the jaxb context builder
   */
  JaxbContextBuilder withContextClassLoader(ClassLoader classLoader);

  /**
   * Specify whether the xml output should be formatted or not.
   *
   * @param formattedOutput the formatted output
   * @return the jaxb context builder
   */
  JaxbContextBuilder withFormattedOutput(boolean formattedOutput);

  /**
   * Sets xml adapters of marshaller and unmarshaller.
   *
   * @param xmlAdapters the xml adapters
   * @return the jaxb context builder
   */
  JaxbContextBuilder withXmlAdapters(Collection&lt;? extends XmlAdapter&lt;?, ?&gt;&gt; xmlAdapters);

  /**
   * Set attachment marshaller.
   *
   * @param attachmentMarshaller the attachment marshaller
   * @return the jaxb context builder
   */
  JaxbContextBuilder withAttachmentMarshaller(AttachmentMarshaller attachmentMarshaller);

  /**
   * Set attachment unmarshaller.
   *
   * @param attachmentUnmarshaller the attachment unmarshaller
   * @return the jaxb context builder
   */
  JaxbContextBuilder withAttachmentUnmarshaller(AttachmentUnmarshaller attachmentUnmarshaller);

  /**
   * Set validation event handler of marshaller and unmarshaller.
   *
   * @param validationEventHandler the validation event handler
   * @return the jaxb context builder
   */
  JaxbContextBuilder withValidationEventHandler(ValidationEventHandler validationEventHandler);


  /**
   * Add jaxb context meta-data to the jaxb context builder.
   *
   * @param data the data
   * @return the jaxb context builder
   */
  JaxbContextBuilder add(JaxbContextMember data);

  /**
   * Add all jaxb context meta-data to the jaxb context builder.
   *
   * @param data the data
   * @return the jaxb context builder
   */
  default JaxbContextBuilder addAll(Iterable&lt;? extends JaxbContextMember&gt; data) {
<span class="fc" id="L163">    return Optional.ofNullable(data)</span>
<span class="fc" id="L164">        .map(d -&gt; addAll(d.iterator()))</span>
<span class="fc" id="L165">        .orElse(this);</span>
  }

  /**
   * Add all jaxb context meta-data to the jaxb context builder.
   *
   * @param data the data
   * @return the jaxb context builder
   */
  default JaxbContextBuilder addAll(Iterator&lt;? extends JaxbContextMember&gt; data) {
<span class="fc" id="L175">    return Optional.ofNullable(data)</span>
<span class="fc" id="L176">        .map(iter -&gt; Spliterators.spliteratorUnknownSize(iter, Spliterator.ORDERED))</span>
<span class="fc" id="L177">        .stream()</span>
<span class="fc" id="L178">        .flatMap(split -&gt; StreamSupport.stream(split, false))</span>
<span class="fc" id="L179">        .map(this::add)</span>
<span class="fc" id="L180">        .reduce((first, second) -&gt; second)</span>
<span class="fc" id="L181">        .orElse(this);</span>
  }

  /**
   * Process the jaxb context meta-data provider and add its data to the jaxb context builder.
   *
   * @param dataProvider the data provider
   * @return the jaxb context builder
   */
  default JaxbContextBuilder process(JaxbContextDataProvider dataProvider) {
<span class="fc" id="L191">    return Optional.ofNullable(dataProvider)</span>
<span class="fc" id="L192">        .map(provider -&gt; addAll(provider.getJaxbContextData()))</span>
<span class="fc" id="L193">        .orElse(this);</span>
  }

  /**
   * Process the jaxb context meta-data providers and add their data to the jaxb context builder.
   *
   * @param dataProviders the data providers
   * @return the jaxb context builder
   */
  default JaxbContextBuilder processAll(
      Iterable&lt;? extends JaxbContextDataProvider&gt; dataProviders) {
<span class="fc" id="L204">    return Optional.ofNullable(dataProviders)</span>
<span class="fc" id="L205">        .map(providers -&gt; processAll(providers.iterator()))</span>
<span class="fc" id="L206">        .orElse(this);</span>
  }

  /**
   * Process the jaxb context meta-data providers and add their data to the jaxb context builder.
   *
   * @param dataProviders the data providers
   * @return the jaxb context builder
   */
  default JaxbContextBuilder processAll(
      Iterator&lt;? extends JaxbContextDataProvider&gt; dataProviders) {
<span class="fc" id="L217">    return Optional.ofNullable(dataProviders)</span>
<span class="fc" id="L218">        .map(iter -&gt; Spliterators.spliteratorUnknownSize(iter, Spliterator.ORDERED))</span>
<span class="fc" id="L219">        .stream()</span>
<span class="fc" id="L220">        .flatMap(split -&gt; StreamSupport.stream(split, false))</span>
<span class="fc" id="L221">        .map(this::process)</span>
<span class="pc" id="L222">        .reduce((first, second) -&gt; second)</span>
<span class="fc" id="L223">        .orElse(this);</span>
  }

  /**
   * Determines whether the unmarshaller can decode xml into an object of the given class.
   *
   * @param clazz the class
   * @return {@code true} if the unmarshaller can decode xml into an object of the given class,
   *     otherwise {@code false}
   */
  default boolean canUnmarshal(Class&lt;?&gt; clazz) {
<span class="fc" id="L234">    return Optional.ofNullable(clazz)</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        .filter(c -&gt; c.isAnnotationPresent(XmlRootElement.class)</span>
<span class="pc bnc" id="L236" title="All 2 branches missed.">            || c.isAnnotationPresent(XmlType.class))</span>
<span class="fc" id="L237">        .isPresent();</span>
  }

  /**
   * Determines whether the marshaller can encode an object of the given class into xml.
   *
   * @param clazz the class
   * @return {@code true} if the marshaller can decode an object of the given class into xml,
   *     otherwise {@code false}
   */
  default boolean canMarshal(Class&lt;?&gt; clazz) {
<span class="fc" id="L248">    return Optional.ofNullable(clazz)</span>
<span class="fc" id="L249">        .filter(c -&gt; c.isAnnotationPresent(XmlRootElement.class))</span>
<span class="fc" id="L250">        .isPresent();</span>
  }

  /**
   * Build unmarshaller for the given classes with the specified dependencies-resolver. If
   * dependency resolving is turned off, an unmarshaller of the default context (defined by the
   * added meta-data) will be returned or one that is created with {@link
   * jakarta.xml.bind.JAXBContext#newInstance(Class[])}*.
   *
   * @param classes the classes that should be processed by the unmarshaller
   * @return the unmarshaller
   * @see JaxbDependenciesResolver
   */
  Unmarshaller buildUnmarshaller(Class&lt;?&gt;... classes);

  /**
   * Build marshaller with the context which is defined by the added meta-data.
   *
   * @return the marshaller
   */
  default Marshaller buildMarshaller() {
<span class="fc" id="L271">    return buildMarshaller(null);</span>
  }

  /**
   * Build marshaller for the given object (POJO) or for the given class or array of classes with
   * the specified dependencies-resolver. If dependency resolving is turned off, a marshaller of the
   * default context (defined by the added meta-data) will be returned or one that is created with
   * {@link jakarta.xml.bind.JAXBContext#newInstance(Class[])}.
   *
   * @param value the value (POJO) that should be processed by the marshaller or a single class
   *     or an array of classes
   * @return the marshaller
   * @see JaxbDependenciesResolver
   */
  Marshaller buildMarshaller(Object value);

  /**
   * Inits default jaxb context. Otherwise, the jaxb context will be created at first usage.
   *
   * @return the jaxb context builder
   */
  JaxbContextBuilder initJaxbContext();

  /**
   * Build default jaxb context that is defined by the added meta-data.
   *
   * @return the jaxb context wrapper
   */
  default JaxbContextWrapper buildJaxbContext() {
<span class="fc" id="L300">    return buildJaxbContext(null);</span>
  }

  /**
   * Build jaxb context for the given object (POJO) or for the given class or array of classes with
   * the specified dependency resolver. If dependency resolving is turned off, the default jaxb
   * context (defined by the added meta-data) will be returned or a jaxb context will be created
   * with {@link jakarta.xml.bind.JAXBContext#newInstance(Class[])}.
   *
   * @param value the value (POJO) that should be processed by the jaxb context or a single
   *     class or an array of classes
   * @return the jaxb context
   */
  JaxbContextWrapper buildJaxbContext(Object value);

  /**
   * Build schema of the default jaxb context (defined by the added meta-data).
   *
   * @return the schema
   */
  default Schema buildSchema() {
<span class="fc" id="L321">    return buildSchema(null);</span>
  }

  /**
   * Build schema of the specified value (POJO), a single class or an array of classes.
   *
   * @param value the value (POJO), a single class or an array of classes for which the schema
   *     should be created
   * @return the schema
   */
  Schema buildSchema(Object value);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>