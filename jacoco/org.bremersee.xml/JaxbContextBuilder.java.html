<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JaxbContextBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">common-xml</a> &gt; <a href="index.source.html" class="el_package">org.bremersee.xml</a> &gt; <span class="el_source">JaxbContextBuilder.java</span></div><h1>JaxbContextBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2018-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bremersee.xml;

import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.function.BiFunction;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.ValidationEventHandler;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.adapters.XmlAdapter;
import javax.xml.bind.attachment.AttachmentMarshaller;
import javax.xml.bind.attachment.AttachmentUnmarshaller;
import javax.xml.validation.Schema;
import org.springframework.util.StringUtils;

/**
 * The jaxb context builder.
 *
 * @author Christian Bremer
 */
public interface JaxbContextBuilder {

  /**
   * The default dependencies resolver implementation.
   *
   * @see #withDependenciesResolver(JaxbDependenciesResolver)
   */
<span class="fc" id="L45">  JaxbDependenciesResolver DEFAULT_DEPENDENCIES_RESOLVER = new JaxbDependenciesResolverImpl();</span>

  /**
   * The can marshal all function. If this function is set, the builder can marshal all objects
   * which are annotated with {@code XmlRootElement}. This is the default behaviour.
   *
   * @see #withCanMarshal(BiFunction)
   */
<span class="fc" id="L53">  BiFunction&lt;Class&lt;?&gt;, Map&lt;String, JaxbContextData&gt;, Boolean&gt; CAN_MARSHAL_ALL</span>
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">      = (aClass, predefinedData) -&gt; aClass != null</span>
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">      &amp;&amp; aClass.isAnnotationPresent(XmlRootElement.class);</span>

  /**
   * The can unmarshal all function. If this function is set, the builder can unmarshal all objects
   * which are annotated with {@code XmlRootElement}. This is the default behaviour.
   *
   * @see #withCanUnmarshal(BiFunction)
   */
<span class="fc" id="L63">  BiFunction&lt;Class&lt;?&gt;, Map&lt;String, JaxbContextData&gt;, Boolean&gt; CAN_UNMARSHAL_ALL</span>
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">      = (aClass, predefinedData) -&gt; aClass != null</span>
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">      &amp;&amp; aClass.isAnnotationPresent(XmlRootElement.class);</span>

  /**
   * The can marshal only predefined data function. If this function is set, the builder can marshal
   * only objects which were added previously to the builder.
   *
   * @see #withCanMarshal(BiFunction)
   */
<span class="fc" id="L73">  BiFunction&lt;Class&lt;?&gt;, Map&lt;String, JaxbContextData&gt;, Boolean&gt; CAN_MARSHAL_ONLY_PREDEFINED_DATA</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">      = (aClass, predefinedData) -&gt; aClass != null</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">      &amp;&amp; aClass.isAnnotationPresent(XmlRootElement.class)</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">      &amp;&amp; predefinedData.containsKey(aClass.getPackage().getName());</span>

  /**
   * The can unmarshal only predefined data function. If this function is set, the builder can
   * unmarshal only objects which were added previously to the builder.
   *
   * @see #withCanUnmarshal(BiFunction)
   */
<span class="fc" id="L84">  BiFunction&lt;Class&lt;?&gt;, Map&lt;String, JaxbContextData&gt;, Boolean&gt; CAN_UNMARSHAL_ONLY_PREDEFINED_DATA</span>
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">      = (aClass, predefinedData) -&gt; aClass != null</span>
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">      &amp;&amp; aClass.isAnnotationPresent(XmlRootElement.class)</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">      &amp;&amp; predefinedData.containsKey(aClass.getPackage().getName());</span>


  /**
   * Creates a new jaxb context builder.
   *
   * @return the jaxb context builder
   */
  static JaxbContextBuilder builder() {
<span class="fc" id="L96">    return new JaxbContextBuilderImpl();</span>
  }


  /**
   * Copy jaxb context builder.
   *
   * @return the jaxb context builder
   */
  JaxbContextBuilder copy();

  /**
   * Sets a function of the builder to determine whether the builder is responsible for the given
   * class. The first parameter of the function is the class, the second is a map with meta data,
   * which were previously added to the builder). The key of the map is a package name.
   *
   * @param function the function
   * @return the jaxb context builder
   * @see #canMarshal(Class)
   */
  JaxbContextBuilder withCanMarshal(
      BiFunction&lt;Class&lt;?&gt;, Map&lt;String, JaxbContextData&gt;, Boolean&gt; function);

  /**
   * Sets a function of the builder to determine whether the builder is responsible for the given
   * class. The first parameter of the function is the class, the second is a map with meta data,
   * which were previously added to the builder). The key of the map is a package name.
   *
   * @param function the function
   * @return the jaxb context builder
   * @see #canUnmarshal(Class)
   */
  JaxbContextBuilder withCanUnmarshal(
      BiFunction&lt;Class&lt;?&gt;, Map&lt;String, JaxbContextData&gt;, Boolean&gt; function);

  /**
   * Specifies whether to add a schema to the marshaller or unmarshaller. The default is to add
   * never a schema to the marshaller or unmarshaller.
   *
   * @param schemaMode the schema mode
   * @return the jaxb context builder
   * @see SchemaMode#NEVER
   * @see SchemaMode#ALWAYS
   * @see SchemaMode#MARSHAL
   * @see SchemaMode#UNMARSHAL
   * @see SchemaMode#EXTERNAL_XSD
   */
  JaxbContextBuilder withSchemaMode(SchemaMode schemaMode);

  /**
   * Specifies the schema builder to generate the schema. The default is the default schema builder
   * implementation (see {@link SchemaBuilder#builder()}).
   *
   * @param schemaBuilder the schema builder
   * @return the jaxb context builder
   */
  JaxbContextBuilder withSchemaBuilder(SchemaBuilder schemaBuilder);

  /**
   * Specifies the dependencies resolver to use. The default jaxb context builder will use a default
   * implementation.
   *
   * &lt;p&gt;To turn off dependency resolving set {@code null} here.
   *
   * @param resolver the resolver
   * @return the jaxb context builder
   */
  JaxbContextBuilder withDependenciesResolver(JaxbDependenciesResolver resolver);

  /**
   * Specifies the class loader to use.
   *
   * @param classLoader the class loader
   * @return the jaxb context builder
   */
  JaxbContextBuilder withContextClassLoader(ClassLoader classLoader);

  /**
   * Specify whether the xml output should be formatted or not.
   *
   * @param formattedOutput the formatted output
   * @return the jaxb context builder
   */
  JaxbContextBuilder withFormattedOutput(boolean formattedOutput);

  /**
   * Sets xml adapters of marshaller and unmarshaller.
   *
   * @param xmlAdapters the xml adapters
   * @return the jaxb context builder
   */
  JaxbContextBuilder withXmlAdapters(Collection&lt;? extends XmlAdapter&lt;?, ?&gt;&gt; xmlAdapters);

  /**
   * Set attachment marshaller.
   *
   * @param attachmentMarshaller the attachment marshaller
   * @return the jaxb context builder
   */
  JaxbContextBuilder withAttachmentMarshaller(AttachmentMarshaller attachmentMarshaller);

  /**
   * Set attachment unmarshaller.
   *
   * @param attachmentUnmarshaller the attachment unmarshaller
   * @return the jaxb context builder
   */
  JaxbContextBuilder withAttachmentUnmarshaller(AttachmentUnmarshaller attachmentUnmarshaller);

  /**
   * Set validation event handler of marshaller and unmarshaller.
   *
   * @param validationEventHandler the validation event handler
   * @return the jaxb context builder
   */
  JaxbContextBuilder withValidationEventHandler(ValidationEventHandler validationEventHandler);


  /**
   * Add the given context path (package names which are separated by colon) to the jaxb context
   * builder. This is the same as {@link javax.xml.bind.JAXBContext#newInstance(String)}.
   *
   * @param contextPath the context path (package names which are separated by colon)
   * @return the jaxb context builder
   */
  default JaxbContextBuilder add(final String contextPath) {
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">    if (StringUtils.hasText(contextPath)) {</span>
<span class="fc" id="L223">      final String[] packages = StringUtils.delimitedListToStringArray(contextPath, &quot;:&quot;);</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">      for (String pakkage : packages) {</span>
<span class="fc" id="L225">        add(new JaxbContextData(pakkage));</span>
      }
    }
<span class="fc" id="L228">    return this;</span>
  }

  /**
   * Add jaxb context meta data to the jaxb context builder.
   *
   * @param data the data
   * @return the jaxb context builder
   */
  JaxbContextBuilder add(JaxbContextData data);

  /**
   * Add all jaxb context meta data to the jaxb context builder.
   *
   * @param data the data
   * @return the jaxb context builder
   */
  default JaxbContextBuilder addAll(final Iterable&lt;? extends JaxbContextData&gt; data) {
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">    return data == null ? this : addAll(data.iterator());</span>
  }

  /**
   * Add all jaxb context meta data to the jaxb context builder.
   *
   * @param data the data
   * @return the jaxb context builder
   */
  default JaxbContextBuilder addAll(final Iterator&lt;? extends JaxbContextData&gt; data) {
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">    if (data != null) {</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">      while (data.hasNext()) {</span>
<span class="fc" id="L258">        add(data.next());</span>
      }
    }
<span class="fc" id="L261">    return this;</span>
  }

  /**
   * Process the jaxb context meta data provider and add it's data to the jaxb context builder.
   *
   * @param dataProvider the data provider
   * @return the jaxb context builder
   */
  default JaxbContextBuilder process(final JaxbContextDataProvider dataProvider) {
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">    return dataProvider == null ? this : addAll(dataProvider.getJaxbContextData());</span>
  }

  /**
   * Process the jaxb context meta data providers and add their data to the jaxb context builder.
   *
   * @param dataProviders the data providers
   * @return the jaxb context builder
   */
  default JaxbContextBuilder processAll(
      final Iterable&lt;? extends JaxbContextDataProvider&gt; dataProviders) {
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">    return dataProviders == null ? this : processAll(dataProviders.iterator());</span>
  }

  /**
   * Process the jaxb context meta data providers and add their data to the jaxb context builder.
   *
   * @param dataProviders the data providers
   * @return the jaxb context builder
   */
  default JaxbContextBuilder processAll(
      final Iterator&lt;? extends JaxbContextDataProvider&gt; dataProviders) {
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">    if (dataProviders != null) {</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">      while (dataProviders.hasNext()) {</span>
<span class="fc" id="L295">        process(dataProviders.next());</span>
      }
    }
<span class="fc" id="L298">    return this;</span>
  }

  /**
   * Determines whether the unmarshaller can decode xml into an object of the given class. The
   * function that is set by {@link #withCanUnmarshal(BiFunction)} will be used.
   *
   * @param clazz the class
   * @return {@code true} if the unmarshaller can decode xml into an object of the given class,
   *     otherwise {@code false}
   */
  boolean canUnmarshal(Class&lt;?&gt; clazz);

  /**
   * Determines whether the marshaller can encode an object of the given class into xml. The
   * function that is set by {@link #withCanMarshal(BiFunction)} will be used.
   *
   * @param clazz the class
   * @return {@code true} if the marshaller can decode an object of the given class into xml,
   *     otherwise {@code false}
   */
  boolean canMarshal(Class&lt;?&gt; clazz);

  /**
   * Build unmarshaller with the context which is defined by the added meta data.
   *
   * @return the unmarshaller
   */
  default Unmarshaller buildUnmarshaller() {
<span class="fc" id="L327">    return buildUnmarshaller(null);</span>
  }

  /**
   * Build unmarshaller for the given object (POJO) or for the given class or array of classes with
   * the specified dependencies resolver. If dependency resolving is turned off, an unmarshaller of
   * the default context (defined by the added meta data) will be returned or one that is created
   * with {@link javax.xml.bind.JAXBContext#newInstance(Class[])}.
   *
   * @param value the value (POJO) that should be processed by the unmarshaller or a single
   *     class or an array of classes
   * @return the unmarshaller
   * @see JaxbDependenciesResolver
   */
  Unmarshaller buildUnmarshaller(Object value);

  /**
   * Build marshaller with the context which is defined by the added meta data.
   *
   * @return the marshaller
   */
  default Marshaller buildMarshaller() {
<span class="fc" id="L349">    return buildMarshaller(null);</span>
  }

  /**
   * Build marshaller for the given object (POJO) or for the given class or array of classes with
   * the specified dependencies resolver. If dependency resolving is turned off, a marshaller of the
   * default context (defined by the added meta data) will be returned or one that is created with
   * {@link javax.xml.bind.JAXBContext#newInstance(Class[])}.
   *
   * @param value the value (POJO) that should be processed by the marshaller or a single class
   *     or an array of classes
   * @return the marshaller
   * @see JaxbDependenciesResolver
   */
  Marshaller buildMarshaller(Object value);

  /**
   * Inits default jaxb context. Otherwise the jaxb context will be created at first usage.
   *
   * @return the jaxb context builder
   */
  JaxbContextBuilder initJaxbContext();

  /**
   * Build default jaxb context that is defined by the added meta data.
   *
   * @return the jaxb context wrapper
   */
  default JaxbContextWrapper buildJaxbContext() {
<span class="fc" id="L378">    return buildJaxbContext(null);</span>
  }

  /**
   * Build jaxb context for the given object (POJO) or for the given class or array of classes with
   * the specified dependencies resolver. If dependency resolving is turned off, the default jaxb
   * context (defined by the added meta data) will be returned or a jaxb context will be created
   * with {@link javax.xml.bind.JAXBContext#newInstance(Class[])}.
   *
   * @param value the value (POJO) that should be processed by the jaxb context or a single
   *     class or an array of classes
   * @return the jaxb context
   */
  JaxbContextWrapper buildJaxbContext(Object value);

  /**
   * Build schema of the default jaxb context (defined by the added meta data).
   *
   * @return the schema
   */
  default Schema buildSchema() {
<span class="fc" id="L399">    return buildSchema(null);</span>
  }

  /**
   * Build schema of the specified value (POJO), a single class or an array of classes.
   *
   * @param value the value (POJO), a single class or an array of classes for which the schema
   *     should be created
   * @return the schema
   */
  Schema buildSchema(Object value);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>