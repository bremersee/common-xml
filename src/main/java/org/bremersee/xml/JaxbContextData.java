/*
 * Copyright 2020-2022  the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bremersee.xml;

import static org.springframework.core.annotation.AnnotationUtils.findAnnotation;
import static org.springframework.util.ObjectUtils.isEmpty;

import java.io.Serializable;
import java.util.Optional;
import javax.xml.bind.annotation.XmlSchema;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;
import org.springframework.core.io.ClassPathResource;
import org.springframework.util.ClassUtils;

/**
 * Meta data to describe a xml model generated by xjb.
 *
 * @author Christian Bremer
 */
@Getter
@EqualsAndHashCode
@ToString
public class JaxbContextData implements Serializable {

  private static final long serialVersionUID = 1L;

  private final String nameSpace;

  private final String schemaLocation;

  private final String packageName;

  /**
   * Instantiates a new Jaxb context data.
   *
   * @param clazz the clazz
   */
  public JaxbContextData(Class<?> clazz) {
    this(isEmpty(clazz) ? null : clazz.getPackage());
  }

  /**
   * Instantiates new jaxb meta-data.
   *
   * @param packageName the package name
   */
  public JaxbContextData(final String packageName) {
    this(getPackageByName(packageName), null, null);
  }

  /**
   * Instantiates new jaxb meta-data.
   *
   * @param packageName the package name
   * @param nameSpace the name space (can be empty or {@code null})
   * @param schemaLocation the schema location (can be {@code null})
   */
  public JaxbContextData(
      final String packageName,
      final String nameSpace,
      final String schemaLocation) {
    this(getPackageByName(packageName), nameSpace, schemaLocation);
  }

  /**
   * Instantiates new jaxb meta-data.
   *
   * @param pakkage the package
   */
  public JaxbContextData(final Package pakkage) {
    this(pakkage, null, null);
  }

  /**
   * Instantiates new jaxb meta-data.
   *
   * @param pakkage the package
   * @param schemaLocation the schema location (can be {@code null})
   */
  public JaxbContextData(
      final Package pakkage,
      final String schemaLocation) {
    this(pakkage, null, schemaLocation);
  }

  /**
   * Instantiates new jaxb meta-data.
   *
   * @param pakkage the package
   * @param nameSpace the name space (can be empty or {@code null})
   * @param schemaLocation the schema location (can be {@code null})
   */
  JaxbContextData(
      final Package pakkage,
      final String nameSpace,
      final String schemaLocation) {

    if (isEmpty(pakkage)) {
      throw new IllegalArgumentException("Package must be present.");
    }
    if (!objectFactoryExists(pakkage) && !jaxbIndexExists(pakkage)) {
      throw new IllegalArgumentException(String.format(
          "Package '%s' does not contain 'ObjectFactory.class' or 'jaxb.index'.",
          pakkage.getName()));
    }
    this.packageName = pakkage.getName();
    final XmlSchema xmlSchema = findAnnotation(pakkage, XmlSchema.class);
    if (!isEmpty(nameSpace)) {
      this.nameSpace = nameSpace;
    } else if (!isEmpty(xmlSchema)) {
      this.nameSpace = xmlSchema.namespace();
    } else {
      this.nameSpace = "";
    }
    if (!isEmpty(schemaLocation)
        && !XmlSchema.NO_LOCATION.equalsIgnoreCase(schemaLocation)) {
      this.schemaLocation = schemaLocation;
    } else if (!isEmpty(xmlSchema)
        && !XmlSchema.NO_LOCATION.equalsIgnoreCase(xmlSchema.location())) {
      this.schemaLocation = xmlSchema.location();
    } else {
      this.schemaLocation = null;
    }
  }

  /**
   * Gets name space with schema location.
   *
   * @return the name space with schema location
   */
  public Optional<String> getNameSpaceWithSchemaLocation() {
    return !isEmpty(getNameSpace()) && !isEmpty(getSchemaLocation())
        ? Optional.of(getNameSpace() + " " + getSchemaLocation())
        : Optional.empty();
  }

  private static Package getPackageByName(String name) {
    //noinspection deprecation
    return Optional.ofNullable(ClassUtils.getDefaultClassLoader())
        .map(classLoader -> classLoader.getDefinedPackage(name))
        .orElseGet(() -> Package.getPackage(name));
  }

  /**
   * From class optional.
   *
   * @param clazz the clazz
   * @return the optional
   */
  public static Optional<JaxbContextData> fromClass(Class<?> clazz) {
    return Optional.ofNullable(clazz)
        .filter(c -> objectFactoryExists(c) || jaxbIndexExists(c))
        .map(Class::getPackage)
        .map(JaxbContextData::new);
  }

  private static boolean objectFactoryExists(Class<?> clazz) {
    return Optional.ofNullable(clazz)
        .map(Class::getPackage)
        .map(JaxbContextData::objectFactoryExists)
        .orElse(false);
  }

  private static boolean objectFactoryExists(Package pakkage) {
    try {
      Class.forName(pakkage.getName() + ".ObjectFactory");
      return true;
    } catch (ClassNotFoundException e) {
      return false;
    }
  }

  private static boolean jaxbIndexExists(Class<?> clazz) {
    return Optional.ofNullable(clazz)
        .map(Class::getPackage)
        .map(JaxbContextData::jaxbIndexExists)
        .orElse(false);
  }

  private static boolean jaxbIndexExists(Package pakkage) {
    return Optional.ofNullable(pakkage)
        .map(Package::getName)
        .map(p -> p.replace('.', '/'))
        .map(path -> path + "/jaxb.index")
        .map(resource -> new ClassPathResource(resource).exists())
        .orElse(false);
  }

}
